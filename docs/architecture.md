# Architecture: `github.com/gwillem/signal-go`

Go library for Signal messenger. Replaces signal-cli (Java) dependency with a pure Go binary. Licensed under AGPL-3.0 (required by libsignal's AGPL-3.0 license — static linking creates a derivative work).

## Goal

Remove the JVM dependency from signalbot. Provide a Go library that can:
1. Register a new Signal account as primary device (SMS verification)
2. Link to an existing Signal account as secondary device
3. Send text messages (1:1 and group)
4. Receive text messages

## Public API

The top-level `signal` package exposes a `Client` that hides internal details (WebSocket URLs, provisioning crypto, store management):

```go
client := signal.NewClient()

// Link as secondary device — blocks until QR code is scanned
err := client.Link(ctx, func(uri string) {
    fmt.Println("Scan:", uri)
})
fmt.Println("Linked to", client.Number())

// Send a message
err = client.Send(ctx, "recipient-aci-uuid", "Hello from signal-go!")

// Receive messages
for msg, err := range client.Receive(ctx) {
    fmt.Printf("[%s] %s: %s\n", msg.Timestamp, msg.SenderNumber, msg.Body)
}

// Sync contacts from primary device (populates SenderNumber/SenderName)
err = client.SyncContacts(ctx)
```

## Non-goals (for now)

- Attachments (beyond contact sync blobs), reactions, read receipts, typing indicators
  - **Not downloading attachments is safe.** Attachments are stored on Signal's CDN (`cdn{2,3}.signal.org`), separate from the message queue. Messages are ACKed immediately after decryption, which clears the queue. Undownloaded attachments auto-expire from CDN after ~30 days. There is no server-side tracking of whether a client fetched an attachment.
- Group v2 management (create, invite, admin)
- Profile updates
- Stories, calls, stickers
- Desktop/multi-platform UI

## Layer diagram

```
┌─────────────────────────────────────────────┐
│  cmd/sgnl                (CLI app)          │
│  - sgnl link: link as secondary device      │
│  - sgnl register: register as primary device│
│  - sgnl send: send text messages            │
│  - sgnl receive: receive + decrypt messages │
│  - sgnl sync-contacts: contact sync         │
├─────────────────────────────────────────────┤
│  client.go                  (public API)    │
│  - Client: Link, Load, Send, Receive        │
│  - SyncContacts, LookupNumber               │
│  - owns Service, delegates to it            │
├─────────────────────────────────────────────┤
│  internal/signalservice                     │
│  ┌────────────────────────────────────────┐ │
│  │  Service        (high-level API)       │ │
│  │  - SendTextMessage, ReceiveMessages    │ │
│  │  - GetPreKeys, UploadPreKeys           │ │
│  │  - GetProfile, SetProfile              │ │
│  │  - owns Transport, Store, Auth         │ │
│  ├────────────────────────────────────────┤ │
│  │  Transport      (HTTP mechanics)       │ │
│  │  - rate limiting (429 retry)           │ │
│  │  - auth header injection               │ │
│  │  - Get, Put, Post, Patch helpers       │ │
│  └────────────────────────────────────────┘ │
│  + provisioning, registration (one-time)    │
│  + WebSocket for message push               │
├─────────────────────────────────────────────┤
│  internal/libsignal         (CGO bindings)  │
│  - key generation, session management       │
│  - encrypt / decrypt (Double Ratchet)       │
│  - sealed sender, retry receipts            │
├─────────────────────────────────────────────┤
│  libsignal_ffi.a + libsignal-ffi.h          │
│  - 48MB static lib, 2080-line C header      │
│  - compiled from signalapp/libsignal        │
│  - source at build/libsignal/ (git submodule) │
└─────────────────────────────────────────────┘
```

### Service / Transport separation

The `signalservice` package separates concerns:

- **Transport** (`transport.go`) — HTTP mechanics only: rate limiting, retries, auth headers, base URL. Provides `Get`, `Put`, `Post`, `Patch` methods.

- **Service** (`service.go`) — High-level API operations. Owns Transport, Store, and credentials. Methods like `SendTextMessage`, `GetPreKeys`, `SetProfile` use Transport internally but hide HTTP details from callers.

This separation means:
1. Business logic doesn't know about TLS config or rate limiting
2. HTTP client is reused (connection pooling)
3. Auth credentials are configured once, not passed per-call

## Build prerequisites

- **Rust nightly toolchain** — required by cbindgen to expand macros (`-Zunpretty=expanded`). Installed via `rustup install nightly`.
- **cbindgen** — generates C header from Rust FFI. Install via `cargo install cbindgen`.
- **Go 1.25+** with CGO enabled.

Build artifacts (generated by `make deps`):
- `internal/libsignal/lib/<os>-<arch>/libsignal_ffi.a` — 48MB static library (per platform)
- `internal/libsignal/lib/libsignal-ffi.h` — 2080-line C header (102KB)

## Why this architecture

**libsignal** (Rust) is Signal's official crypto library. Its C FFI exposes protocol primitives: key generation, session cipher, sealed sender. We bind these via CGO.

The C FFI does **not** cover server communication (HTTP, WebSocket, provisioning). That lives in `libsignal-service` (Java module inside Signal-Android). We reimplement the minimal subset in pure Go.

**Primary reference:** Signal-Android's `lib/libsignal-service/` module (official, canonical).
**Pattern reference:** `sumnerevans/libsignalgo` (archived CGO bindings, proves the approach works). Clean-room implementation — use as pattern reference only, not fork.

### Why Signal-Android as primary reference (not signal-cli)

Signal no longer publishes `libsignal-service-java` as a standalone artifact. It lives inside Signal-Android's `lib/libsignal-service/`, tightly coupled to Android (GCM, etc). signal-cli works around this by depending on the **Turasa fork** (`com.github.turasa:signal-service-java`), which strips GCM, adds device provisioning support, and carries bug fixes for non-Android usage. That fork has been maintained since 2016 but is inherently a third-party derivative.

Since we're writing the service layer in pure Go, we skip both problems: no GCM coupling, no need for a Java fork. We reference Signal-Android's `lib/libsignal-service/` directly as the canonical source of truth for the server protocol.

### Alternatives considered

| Approach | Verdict |
|---|---|
| Fork sumnerevans/libsignalgo | Archived, pinned to old libsignal commit, noted memory leaks |
| CGO to presage (Rust client) | No C FFI exposed |
| Pure Go (go.mau.fi/libsignal) | Diverges from official crypto |
| signal-cli subprocess/JSON-RPC | Requires JVM — exactly what we're replacing |
| Use Turasa fork of libsignal-service-java | Still Java; third-party fork tracking Signal-Android |

## Package structure

```
signal-go/
├── build/libsignal/                  # Git submodule (signalapp/libsignal, pinned v0.87.0)
├── Makefile                        # Build libsignal Rust → .a + .h
├── LICENSE                         # AGPL-3.0
├── CLAUDE.md                       # Development instructions
├── client.go                       # Public API — Client, Link, Load, Send, Receive, SyncContacts
├── internal/
│   ├── libsignal/                  # CGO bindings — COMPLETE (Task 01)
│   │   ├── lib/                    # Build artefacts (gitignored)
│   │   │   ├── libsignal-ffi.h    # Generated C header
│   │   │   ├── darwin-arm64/      # macOS ARM64 static lib
│   │   │   └── linux-amd64/       # Linux x86_64 static lib
│   │   ├── libsignal.go           # CGO preamble, LDFLAGS
│   │   ├── error.go               # FFI error wrapping + buffer helpers
│   │   ├── privatekey.go          # PrivateKey (generate, serialize, sign, agree)
│   │   ├── publickey.go           # PublicKey (derive, serialize, verify, compare)
│   │   ├── identitykey.go         # IdentityKeyPair
│   │   ├── address.go             # ProtocolAddress
│   │   ├── prekey.go              # PreKeyRecord, SignedPreKeyRecord
│   │   ├── kyberprekey.go         # KyberKeyPair, KyberPreKeyRecord (post-quantum)
│   │   ├── prekeybundle.go        # PreKeyBundle
│   │   ├── session.go             # SessionRecord
│   │   ├── message.go             # CiphertextMessage, PreKeySignalMessage, SignalMessage
│   │   ├── store.go               # Store interfaces (5 types)
│   │   ├── callbacks.go           # CGO //export callbacks + store wrappers
│   │   ├── bridge.c               # C bridge: unwrap SignalConstPointer* structs
│   │   ├── pointer.go             # Handle map for Go→C→Go pointer passing
│   │   ├── memstore.go            # In-memory store implementations (testing)
│   │   ├── protocol.go            # ProcessPreKeyBundle, Encrypt, Decrypt
│   │   ├── sealedsender.go        # SealedSenderDecrypt, SealedSenderDecryptToUSMC
│   │   ├── decryptionerror.go     # DecryptionErrorMessage CGO bindings
│   │   └── plaintextcontent.go    # PlaintextContent CGO bindings
│   ├── proto/                      # Protobuf definitions + generated Go code
│   │   ├── Provisioning.proto     # ProvisionEnvelope, ProvisionMessage, ProvisioningAddress
│   │   ├── WebSocketResources.proto # WebSocketMessage, Request, Response
│   │   ├── SignalService.proto    # Envelope, Content, DataMessage, SyncMessage, ContactDetails
│   │   └── generate.go            # go:generate directive for protoc
│   ├── provisioncrypto/            # Provisioning envelope crypto (complete)
│   │   ├── pkcs7.go               # PKCS#7 pad/unpad
│   │   ├── kdf.go                 # HKDF-SHA256 key derivation
│   │   ├── mac.go                 # HMAC-SHA256 compute + verify
│   │   ├── aescbc.go              # AES-256-CBC encrypt/decrypt
│   │   ├── provision.go           # Full envelope decrypt pipeline
│   │   └── provisiondata.go       # ProvisionMessage → ProvisionData parsing
│   ├── signalws/                   # WebSocket framing layer (complete)
│   │   ├── conn.go                # Protobuf-framed read/write/ACK over WebSocket
│   │   └── persistent.go          # PersistentConn: keep-alive + reconnection
│   ├── signalservice/              # Signal server protocol (complete)
│   │   ├── linkuri.go             # Device link URI formatting
│   │   ├── provisioning.go        # Provisioning orchestration
│   │   ├── httpclient.go          # HTTP client (REST API)
│   │   ├── httptypes.go           # JSON request/response types
│   │   ├── sender.go              # Message sending + SendNullMessage
│   │   ├── receiver.go            # Message receive loop + retry receipts + contact sync
│   │   ├── retryreceipt.go        # DecryptionErrorMessage retry flow
│   │   ├── attachment.go          # CDN attachment download + AES-CBC decryption
│   │   ├── contactsync.go         # ParseContactStream, RequestContactSync
│   │   ├── dump.go                # Raw envelope debug dump
│   │   ├── keygen.go              # Pre-key set generation
│   │   ├── registration.go        # RegisterLinkedDevice orchestration
│   │   └── trustroot.go           # Sealed sender trust root keys
│   └── store/                      # SQLite persistent storage (modernc.org/sqlite)
│       ├── store.go               # Open, Close, schema, SetIdentity
│       ├── account.go             # Account CRUD
│       ├── session.go             # SessionStore + ArchiveSession
│       ├── identity.go            # IdentityKeyStore (TOFU)
│       ├── prekey.go              # PreKeyStore, SignedPreKeyStore, KyberPreKeyStore
│       └── contact.go             # Contact CRUD (ACI→number/name)
└── cmd/
    └── sgnl/                       # CLI: link, send, receive, sync-contacts, devices
```

## Dependencies

Task 01 has zero external Go dependencies (CGO only).

Task 02 adds:

| Dependency | Purpose |
|---|---|
| `google.golang.org/protobuf` | Protobuf runtime |
| `github.com/coder/websocket` | WebSocket client |
| `golang.org/x/crypto` | HKDF (provisioning key derivation) |
| `modernc.org/sqlite` | Pure-Go SQLite for persistent storage |
| `github.com/jessevdk/go-flags` | CLI argument parsing |

Note: `nhooyr.io/websocket` was the original plan but it is deprecated — the maintainer moved to `github.com/coder/websocket` (same API).

## Design decisions

### Single-account Client, caller-managed concurrency

The `Client` owns exactly one device identity and one WebSocket connection. Multi-account usage (receiving messages for N accounts) is handled by the caller instantiating N `Client`s, not by a library-level multi-account manager.

Rationale:
- Each Signal account requires its own authenticated WebSocket (`wss://chat.signal.org/v1/websocket/?login={aci}.{deviceId}&password={pass}`). There is no server-side multiplexing — N accounts always means N connections.
- A library-level pool would need per-account error handling, reconnection backoff, credential storage, lifecycle management, and account add/remove — all things the caller already has opinions about.
- Go's concurrency primitives (goroutines, channels, contexts) make caller-side pooling trivial.

The library provides a single-account receive primitive (channel or callback based). The caller composes multiple instances as needed:

```go
for _, acct := range accounts {
    client := signal.NewClient(signal.WithStore(acct.Store))
    go func() {
        for msg := range client.Messages(ctx) {
            handler(acct, msg)
        }
    }()
}
```

This follows the same pattern as `database/sql` (one `*DB` per database) and `net/http` (one `Client` per config).

### Send-only usage

A send-only client is viable. Sending requires only an authenticated HTTP `PUT /v1/messages/{destination}` — no WebSocket receive loop needed. Caveats: the server may garbage-collect devices that never connect via WebSocket (~30 days inactivity), and pre-key supply won't be replenished (only matters for others initiating new sessions with you).

## Key technical challenges

### CGO store callbacks

libsignal's C FFI takes callback structs (function pointers + `void *ctx`) for store operations. Go can't pass closures as C function pointers. Solution:

1. **`pointer.go`** — a handle map that stores Go interfaces keyed by incrementing `uintptr`, passed as C `void*` (no external dependency)
2. **`callbacks.go`** — `//export` Go functions that receive raw C pointers and dispatch to the appropriate Go store interface
3. **`bridge.c`** — C bridge functions that unwrap `SignalConstPointer*` by-value wrapper structs to raw pointers before calling Go exports (required because CGO `//export` functions can't reliably receive C structs by value)

The actual store structs from the header (e.g. `SignalSessionStore`) contain a `void *ctx` plus typed function pointers like `SignalLoadSession`, `SignalStoreSession`.

### Memory management across FFI

Every C-allocated object must be explicitly freed. Each Go wrapper has a `Destroy()` method calling `signal_*_destroy()`. Double `Destroy()` is safe (nil-guarded).

The FFI uses wrapper types (`SignalMutPointer*`, `SignalConstPointer*`) around raw pointers — each is a single-field struct containing `raw`.

Borrowed C pointers in callbacks (e.g. session records, public keys passed by libsignal) are cloned via serialize/deserialize before storing in Go memory.

Store wrappers (`wrapSessionStore()` etc.) register Go interfaces in the handle map via `savePointer()` and return a cleanup function. Callers must defer cleanup to avoid leaking handles. In-memory stores must `Destroy()` old records before overwriting map entries.

### Async FFI bridge (CDSI)

libsignal's CDSI client uses async Rust (tokio). The C FFI exposes this via **promise structs**: the caller fills in a `complete` callback and a `context` pointer, then calls the async function. Rust spawns the work on a tokio runtime and invokes the callback when done.

Bridging this to Go has two CGO-specific constraints:

1. **Promise structs can't live on the Go stack.** They contain a Go pointer (the context handle from `savePointer`). CGO's pointer checker rejects Go pointers inside Go-stack-allocated C structs. Solution: C inline functions construct the promise AND call the FFI function entirely on the C side — the promise never exists in Go memory.

2. **Go pointers must bypass CGO's pointer check.** The context handle is passed as `uintptr_t` (integer, not pointer), then cast back to `const void*` on the C side. This is safe because the handle wrapper is pinned via `runtime.Pinner`.

The Go side uses a buffered channel (size 1) per async operation:

```
Go                          C/Rust
─────────────────────────── ──────────────────────────
ch := make(chan result, 1)
ctx := savePointer(ch)
                         ──→ construct promise{callback, ctx}
                             signal_cdsi_lookup_new(&promise, ...)
                             Rust spawns async work on tokio
select {                     ...
case r := <-ch:              callback fires → //export Go func
                               restorePointer(ctx) → ch
                               deletePointer(ctx)
                               ch <- result
  return r
case <-time.After(30s):      (late callback still cleans up)
  return timeout error
}
```

**Cleanup ownership:** the `//export` callback always calls `deletePointer`, not the Go receive side. This way a late-arriving callback (after Go timed out) still frees its handle instead of leaking.

### Provisioning envelope crypto

Provisioning message decryption is application-level crypto, not part of libsignal FFI:
- ECDH shared secret → HKDF (info="TextSecure Provisioning Message") → 32-byte AES key + 32-byte MAC key
- Verify HMAC-SHA256, then AES-256-CBC decrypt with PKCS7 unpadding
- Pure Go: `crypto/aes`, `crypto/hmac`, `golang.org/x/crypto/hkdf`

### Message sending

Sending requires:
1. Fetch recipient's pre-key bundle from server
2. Establish session (if not exists)
3. Encrypt Content protobuf via session cipher
4. PUT encrypted envelope to `/v1/messages/{destination}`

This is covered in Signal-Android's `SignalServiceMessageSender.java`.

### Group messaging and sender keys

Signal uses **sender keys** for efficient group messaging. Instead of encrypting a message N times for N recipients (fanout), the sender encrypts once with a symmetric sender key that all group members share.

#### Message types

| Type | Name | Use |
|------|------|-----|
| 2 | Whisper | Regular 1:1 message (established session) |
| 3 | PreKey | 1:1 message establishing new session |
| 7 | SenderKey | Group message encrypted with sender key |
| 8 | Plaintext | Unencrypted (retry receipts only) |

#### Sender key flow

1. **Distribution**: Before sending to a group, the sender creates a `SenderKeyDistributionMessage` and sends it to all group members inside a regular encrypted message (type 2/3). This is in `Content.senderKeyDistributionMessage`.

2. **Storage**: Recipients process the distribution message and store the sender key record, keyed by `(sender_address, distribution_id)`.

3. **Group send**: The sender encrypts the message once with the sender key, producing a type 7 message. The same ciphertext goes to all recipients.

4. **Decryption**: Recipients decrypt using `signal_group_decrypt_message` with the stored sender key.

#### Single-shot sending and SKDM delivery

Signal-Android runs a persistent WebSocket and processes incoming messages continuously. When a recipient can't decrypt a sender key message, they send a **retry receipt** back. Signal-Android processes it, re-sends the SKDM, and the recipient retries — all happening on the same connection.

A CLI tool doing one-shot sends can't rely on this feedback loop. The sender exits before retry receipts arrive. This creates a fundamental problem: if SKDM delivery fails silently (stale session, device not ready), the group message is unreadable and there's no chance to retry.

**signal-go's approach**: always re-send SKDM to all group members on every send, with fresh sessions. This has two parts:

1. **Archive all recipient sessions** before sending SKDM. This forces fresh PreKey establishment, guaranteeing the SKDM is encrypted with a session the recipient can decrypt. Without this, a stale Double Ratchet state (from missed messages, session resets, etc.) would make the SKDM unreadable and the group message undecryptable.

2. **Always re-send SKDM** to all members (no delivery tracking). SKDM delivery tracking (`sender_key_shared` table) exists in the database schema but is not used during sends — it's reserved for future use when a persistent connection enables delivery-confirmed tracking.

The send flow is:
1. Archive recipient sessions (forces fresh PreKey for SKDM)
2. Send SKDM to all members via 1:1 sealed sender (PreKey messages)
3. Encrypt once with sender key
4. Multi-recipient encrypt (SSv2) → single `PUT /v1/messages/multi_recipient`
5. Group-Send-Token header (from endorsements, not per-recipient access keys)

#### signal-cli vs Signal-Android behavior

**signal-cli** uses aggressive fallback:
- Evaluates each recipient for "sender key capability"
- Falls back to **legacy fanout** (individual type 2/3 messages) if fewer than 2 recipients support sender keys, or if sender key delivery fails
- This means signal-cli group messages may arrive as regular 1:1 messages

**Signal-Android** is optimized for sender keys:
- Prefers sender keys for efficiency
- When decryption fails, expects the recipient to send a retry receipt
- The sender then re-distributes the key and retries
- Less eager to fall back to legacy fanout

**Implication**: A client that doesn't handle type 7 messages will receive group messages from signal-cli (via fallback) but not from Signal-Android (which persists with sender keys).

#### Group membership discovery

Groups are stored in Signal's **Storage Service**, not the messaging protocol:
1. Sync encrypted storage records via `/v2/storage/`
2. Parse `GroupV2Record` entries containing group master keys
3. Use Groups V2 API with zero-knowledge credentials to fetch group state

This requires libsignal's `zkgroup` module for zero-knowledge proofs. signal-go implements Storage Service sync, Groups V2 API, and auto-fetches group names on first message via `FetchGroupDetails`.

## Reference sources

| Source | Location | What to learn |
|---|---|---|
| Signal-Android libsignal-service | `../Signal-Android/lib/libsignal-service/` | Official service layer (canonical) |
| Signal-Android protobuf | `../Signal-Android/lib/libsignal-service/src/main/protowire/` | Message formats |
| libsignal Rust FFI | `build/libsignal/rust/bridge/ffi/` | C FFI source, cbindgen config (git submodule) |
| Generated C header | `internal/libsignal/lib/libsignal-ffi.h` | Actual FFI function signatures |
| libsignalgo (archived) | `../libsignalgo/` | CGO callback patterns (reference only) |
| signalbot | `../signalbot/internal/signal/` | Current use case, target API shape |
