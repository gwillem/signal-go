# Architecture: `github.com/gwillem/signal-go`

Go library for Signal messenger. Replaces signal-cli (Java) dependency with a pure Go binary. Licensed under AGPL-3.0 (required by libsignal's AGPL-3.0 license — static linking creates a derivative work).

## Goal

Remove the JVM dependency from signalbot. Provide a Go library that can:
1. Link to an existing Signal account as secondary device
2. Send text messages (1:1 and group)
3. Receive text messages

## Public API

The top-level `signal` package exposes a `Client` that hides internal details (WebSocket URLs, provisioning crypto, store management):

```go
client := signal.NewClient()

// Link as secondary device — blocks until QR code is scanned
err := client.Link(ctx, func(uri string) {
    fmt.Println("Scan:", uri)
})
fmt.Println("Linked to", client.Number())

// Send (not yet implemented)
err = client.Send(ctx, "+31612345678", "Hello from signal-go!")

// Receive (not yet implemented)
for msg := range client.Receive(ctx) {
    fmt.Printf("%s: %s\n", msg.From, msg.Body)
}
```

## Non-goals (for now)

- Attachments, reactions, read receipts, typing indicators
- Group v2 management (create, invite, admin)
- Profile updates, contact sync
- Registration as primary device
- Stories, calls, stickers
- Desktop/multi-platform UI

## Layer diagram

```
┌─────────────────────────────────────────────┐
│  cmd/signal-link         (demo CLI app)     │
│  - link as secondary device                 │
│  - send and receive text messages           │
├─────────────────────────────────────────────┤
│  client.go                  (public API)  │
│  - Client: Link, Send, Receive              │
│  - hides WebSocket URLs, crypto, stores     │
├─────────────────────────────────────────────┤
│  internal/signalservice     (pure Go)     │
│  - HTTP client for Signal REST API          │
│  - WebSocket for message push               │
│  - device provisioning (linking)            │
│  - message send / receive                   │
├─────────────────────────────────────────────┤
│  internal/libsignal         (CGO bindings)│
│  - key generation, session management       │
│  - encrypt / decrypt (Double Ratchet)       │
├─────────────────────────────────────────────┤
│  libsignal_ffi.a + libsignal-ffi.h          │
│  - 48MB static lib, 2080-line C header      │
│  - compiled from signalapp/libsignal        │
│  - source at ../libsignal                   │
└─────────────────────────────────────────────┘
```

## Build prerequisites

- **Rust nightly toolchain** — required by cbindgen to expand macros (`-Zunpretty=expanded`). Installed via `rustup install nightly`.
- **cbindgen** — generates C header from Rust FFI. Install via `cargo install cbindgen`.
- **Go 1.25+** with CGO enabled.

Build artifacts (generated by `make build`):
- `../libsignal/target/release/libsignal_ffi.a` — 48MB static library
- `internal/libsignal/libsignal-ffi.h` — 2080-line C header (102KB)

## Why this architecture

**libsignal** (Rust) is Signal's official crypto library. Its C FFI exposes protocol primitives: key generation, session cipher, sealed sender. We bind these via CGO.

The C FFI does **not** cover server communication (HTTP, WebSocket, provisioning). That lives in `libsignal-service` (Java module inside Signal-Android). We reimplement the minimal subset in pure Go.

**Primary reference:** Signal-Android's `lib/libsignal-service/` module (official, canonical).
**Pattern reference:** `sumnerevans/libsignalgo` (archived CGO bindings, proves the approach works). Clean-room implementation — use as pattern reference only, not fork.

### Why Signal-Android as primary reference (not signal-cli)

Signal no longer publishes `libsignal-service-java` as a standalone artifact. It lives inside Signal-Android's `lib/libsignal-service/`, tightly coupled to Android (GCM, etc). signal-cli works around this by depending on the **Turasa fork** (`com.github.turasa:signal-service-java`), which strips GCM, adds device provisioning support, and carries bug fixes for non-Android usage. That fork has been maintained since 2016 but is inherently a third-party derivative.

Since we're writing the service layer in pure Go, we skip both problems: no GCM coupling, no need for a Java fork. We reference Signal-Android's `lib/libsignal-service/` directly as the canonical source of truth for the server protocol.

### Alternatives considered

| Approach | Verdict |
|---|---|
| Fork sumnerevans/libsignalgo | Archived, pinned to old libsignal commit, noted memory leaks |
| CGO to presage (Rust client) | No C FFI exposed |
| Pure Go (go.mau.fi/libsignal) | Diverges from official crypto |
| signal-cli subprocess/JSON-RPC | Requires JVM — exactly what we're replacing |
| Use Turasa fork of libsignal-service-java | Still Java; third-party fork tracking Signal-Android |

## Package structure

```
signal-go/
├── Makefile                        # Build libsignal Rust → .a + .h
├── LICENSE                         # AGPL-3.0
├── CLAUDE.md                       # Development instructions
├── client.go                       # Public API — Client, Link, Number
├── internal/
│   ├── libsignal/                  # CGO bindings — COMPLETE (Phase 1)
│   │   ├── libsignal-ffi.h        # Generated C header (gitignored)
│   │   ├── libsignal.go           # CGO preamble, LDFLAGS
│   │   ├── error.go               # FFI error wrapping + buffer helpers
│   │   ├── privatekey.go          # PrivateKey (generate, serialize, sign, agree)
│   │   ├── publickey.go           # PublicKey (derive, serialize, verify, compare)
│   │   ├── identitykey.go         # IdentityKeyPair
│   │   ├── address.go             # ProtocolAddress
│   │   ├── prekey.go              # PreKeyRecord, SignedPreKeyRecord
│   │   ├── kyberprekey.go         # KyberKeyPair, KyberPreKeyRecord (post-quantum)
│   │   ├── prekeybundle.go        # PreKeyBundle
│   │   ├── session.go             # SessionRecord
│   │   ├── message.go             # CiphertextMessage, PreKeySignalMessage, SignalMessage
│   │   ├── store.go               # Store interfaces (5 types)
│   │   ├── callbacks.go           # CGO //export callbacks + store wrappers
│   │   ├── bridge.c               # C bridge: unwrap SignalConstPointer* structs
│   │   ├── pointer.go             # Handle map for Go→C→Go pointer passing
│   │   ├── memstore.go            # In-memory store implementations (testing)
│   │   └── protocol.go            # ProcessPreKeyBundle, Encrypt, Decrypt
│   ├── proto/                      # Protobuf definitions + generated Go code (Phase 2)
│   │   ├── Provisioning.proto     # ProvisionEnvelope, ProvisionMessage, ProvisioningAddress
│   │   ├── WebSocketResources.proto # WebSocketMessage, Request, Response
│   │   ├── Provisioning.pb.go    # Generated
│   │   ├── WebSocketResources.pb.go # Generated
│   │   └── generate.go            # go:generate directive for protoc
│   ├── provisioncrypto/            # Provisioning envelope crypto (Phase 2, complete)
│   │   ├── pkcs7.go               # PKCS#7 pad/unpad
│   │   ├── kdf.go                 # HKDF-SHA256 key derivation
│   │   ├── mac.go                 # HMAC-SHA256 compute + verify
│   │   ├── aescbc.go              # AES-256-CBC encrypt/decrypt
│   │   ├── provision.go           # Full envelope decrypt pipeline
│   │   └── provisiondata.go       # ProvisionMessage → ProvisionData parsing
│   ├── signalws/                   # WebSocket framing layer (Phase 2, complete)
│   │   └── conn.go                # Protobuf-framed read/write/ACK over WebSocket
│   ├── signalservice/              # Signal server protocol (Phase 2, in progress)
│   │   ├── linkuri.go             # Device link URI formatting
│   │   ├── provisioning.go        # Provisioning orchestration (complete)
│   │   ├── client.go              # HTTP client (REST API) — not started
│   │   ├── sender.go              # Message sending — not started
│   │   └── receiver.go            # Message receive loop — not started
│   └── store/
│       └── sqlite/                 # Persistent store (modernc.org/sqlite)
└── cmd/
    └── signal-link/                # Demo: link + send + receive
```

## Dependencies

Phase 1 has zero external Go dependencies (CGO only).

Phase 2 adds:

| Dependency | Purpose | Status |
|---|---|---|
| `google.golang.org/protobuf` | Protobuf runtime | Added |
| `github.com/coder/websocket` | WebSocket client | Added |
| `golang.org/x/crypto` | HKDF (provisioning key derivation) | Added |
| `modernc.org/sqlite` | Pure-Go SQLite for persistent storage | Not yet |

Note: `nhooyr.io/websocket` was the original plan but it is deprecated — the maintainer moved to `github.com/coder/websocket` (same API).

## Key technical challenges

### CGO store callbacks

libsignal's C FFI takes callback structs (function pointers + `void *ctx`) for store operations. Go can't pass closures as C function pointers. Solution:

1. **`pointer.go`** — a handle map that stores Go interfaces keyed by incrementing `uintptr`, passed as C `void*` (no external dependency)
2. **`callbacks.go`** — `//export` Go functions that receive raw C pointers and dispatch to the appropriate Go store interface
3. **`bridge.c`** — C bridge functions that unwrap `SignalConstPointer*` by-value wrapper structs to raw pointers before calling Go exports (required because CGO `//export` functions can't reliably receive C structs by value)

The actual store structs from the header (e.g. `SignalSessionStore`) contain a `void *ctx` plus typed function pointers like `SignalLoadSession`, `SignalStoreSession`.

### Memory management across FFI

Every C-allocated object must be explicitly freed. Each Go wrapper has a `Destroy()` method calling `signal_*_destroy()`. Double `Destroy()` is safe (nil-guarded).

The FFI uses wrapper types (`SignalMutPointer*`, `SignalConstPointer*`) around raw pointers — each is a single-field struct containing `raw`.

Borrowed C pointers in callbacks (e.g. session records, public keys passed by libsignal) are cloned via serialize/deserialize before storing in Go memory.

Store wrappers (`wrapSessionStore()` etc.) register Go interfaces in the handle map via `savePointer()` and return a cleanup function. Callers must defer cleanup to avoid leaking handles. In-memory stores must `Destroy()` old records before overwriting map entries.

### Provisioning envelope crypto

Provisioning message decryption is application-level crypto, not part of libsignal FFI:
- ECDH shared secret → HKDF (info="TextSecure Provisioning Message") → 32-byte AES key + 32-byte MAC key
- Verify HMAC-SHA256, then AES-256-CBC decrypt with PKCS7 unpadding
- Pure Go: `crypto/aes`, `crypto/hmac`, `golang.org/x/crypto/hkdf`

### Message sending

Sending requires:
1. Fetch recipient's pre-key bundle from server
2. Establish session (if not exists)
3. Encrypt Content protobuf via session cipher
4. PUT encrypted envelope to `/v1/messages/{destination}`

This is covered in Signal-Android's `SignalServiceMessageSender.java`.

## Reference sources

| Source | Location | What to learn |
|---|---|---|
| Signal-Android libsignal-service | `../Signal-Android/lib/libsignal-service/` | Official service layer (canonical) |
| Signal-Android protobuf | `../Signal-Android/lib/libsignal-service/src/main/protowire/` | Message formats |
| libsignal Rust FFI | `../libsignal/rust/bridge/ffi/` | C FFI source, cbindgen config |
| Generated C header | `internal/libsignal/libsignal-ffi.h` | Actual FFI function signatures |
| libsignalgo (archived) | `../libsignalgo/` | CGO callback patterns (reference only) |
| signalbot | `../signalbot/internal/signal/` | Current use case, target API shape |
