# Architecture: `github.com/gwillem/signal-go`

Go library for Signal messenger. Replaces signal-cli (Java) dependency with a pure Go binary. Licensed under AGPL-3.0 (required by libsignal's AGPL-3.0 license — static linking creates a derivative work).

## Goal

Remove the JVM dependency from signalbot. Provide a Go library that can:
1. Link to an existing Signal account as secondary device
2. Send text messages (1:1 and group)
3. Receive text messages

## Non-goals (for now)

- Attachments, reactions, read receipts, typing indicators
- Group v2 management (create, invite, admin)
- Profile updates, contact sync
- Registration as primary device
- Stories, calls, stickers
- Desktop/multi-platform UI

## Layer diagram

```
┌─────────────────────────────────────────────┐
│  cmd/signal-link         (demo CLI app)     │
│  - link as secondary device                 │
│  - send and receive text messages           │
├─────────────────────────────────────────────┤
│  pkg/signalservice       (pure Go)          │
│  - HTTP client for Signal REST API          │
│  - WebSocket for message push               │
│  - device provisioning (linking)            │
│  - message send / receive                   │
├─────────────────────────────────────────────┤
│  pkg/libsignal           (CGO bindings)     │
│  - key generation, session management       │
│  - encrypt / decrypt (Double Ratchet)       │
├─────────────────────────────────────────────┤
│  libsignal_ffi.a + libsignal-ffi.h          │
│  - 48MB static lib, 2080-line C header      │
│  - compiled from signalapp/libsignal        │
│  - source at ../libsignal                   │
└─────────────────────────────────────────────┘
```

## Build prerequisites

- **Rust nightly toolchain** — required by cbindgen to expand macros (`-Zunpretty=expanded`). Installed via `rustup install nightly`.
- **cbindgen** — generates C header from Rust FFI. Install via `cargo install cbindgen`.
- **Go 1.25+** with CGO enabled.

Build artifacts (generated by `make build`):
- `../libsignal/target/release/libsignal_ffi.a` — 48MB static library
- `pkg/libsignal/libsignal-ffi.h` — 2080-line C header (102KB)

## Why this architecture

**libsignal** (Rust) is Signal's official crypto library. Its C FFI exposes protocol primitives: key generation, session cipher, sealed sender. We bind these via CGO.

The C FFI does **not** cover server communication (HTTP, WebSocket, provisioning). That lives in `libsignal-service` (Java module inside Signal-Android). We reimplement the minimal subset in pure Go.

**Primary reference:** Signal-Android's `lib/libsignal-service/` module (official, canonical).
**Pattern reference:** `sumnerevans/libsignalgo` (archived CGO bindings, proves the approach works). Clean-room implementation — use as pattern reference only, not fork.

### Why Signal-Android as primary reference (not signal-cli)

Signal no longer publishes `libsignal-service-java` as a standalone artifact. It lives inside Signal-Android's `lib/libsignal-service/`, tightly coupled to Android (GCM, etc). signal-cli works around this by depending on the **Turasa fork** (`com.github.turasa:signal-service-java`), which strips GCM, adds device provisioning support, and carries bug fixes for non-Android usage. That fork has been maintained since 2016 but is inherently a third-party derivative.

Since we're writing the service layer in pure Go, we skip both problems: no GCM coupling, no need for a Java fork. We reference Signal-Android's `lib/libsignal-service/` directly as the canonical source of truth for the server protocol.

### Alternatives considered

| Approach | Verdict |
|---|---|
| Fork sumnerevans/libsignalgo | Archived, pinned to old libsignal commit, noted memory leaks |
| CGO to presage (Rust client) | No C FFI exposed |
| Pure Go (go.mau.fi/libsignal) | Diverges from official crypto |
| signal-cli subprocess/JSON-RPC | Requires JVM — exactly what we're replacing |
| Use Turasa fork of libsignal-service-java | Still Java; third-party fork tracking Signal-Android |

## Package structure

```
signal-go/
├── Makefile                        # Build libsignal Rust → .a + .h
├── LICENSE                         # AGPL-3.0
├── CLAUDE.md                       # Development instructions
├── pkg/
│   ├── libsignal/                  # CGO bindings — COMPLETE (Phase 1)
│   │   ├── libsignal-ffi.h        # Generated C header (gitignored)
│   │   ├── libsignal.go           # CGO preamble, LDFLAGS
│   │   ├── error.go               # FFI error wrapping + buffer helpers
│   │   ├── privatekey.go          # PrivateKey (generate, serialize, sign, agree)
│   │   ├── publickey.go           # PublicKey (derive, serialize, verify, compare)
│   │   ├── identitykey.go         # IdentityKeyPair
│   │   ├── address.go             # ProtocolAddress
│   │   ├── prekey.go              # PreKeyRecord, SignedPreKeyRecord
│   │   ├── kyberprekey.go         # KyberKeyPair, KyberPreKeyRecord (post-quantum)
│   │   ├── prekeybundle.go        # PreKeyBundle
│   │   ├── session.go             # SessionRecord
│   │   ├── message.go             # CiphertextMessage, PreKeySignalMessage, SignalMessage
│   │   ├── store.go               # Store interfaces (5 types)
│   │   ├── callbacks.go           # CGO //export callbacks + store wrappers
│   │   ├── bridge.c               # C bridge: unwrap SignalConstPointer* structs
│   │   ├── pointer.go             # Handle map for Go→C→Go pointer passing
│   │   ├── memstore.go            # In-memory store implementations (testing)
│   │   └── protocol.go            # ProcessPreKeyBundle, Encrypt, Decrypt
│   ├── signalservice/              # Signal server protocol — NOT STARTED (Phase 2)
│   │   ├── client.go              # HTTP client (REST API)
│   │   ├── websocket.go           # WebSocket framing
│   │   ├── provisioning.go        # Device linking
│   │   ├── sender.go              # Message sending
│   │   ├── cipher.go              # Envelope encrypt/decrypt
│   │   └── receiver.go            # Message receive loop
│   ├── proto/                      # Protobuf definitions + generated code
│   └── store/
│       └── sqlite/                 # Persistent store (modernc.org/sqlite)
└── cmd/
    └── signal-link/                # Demo: link + send + receive
```

## Dependencies

Phase 1 has zero external Go dependencies (CGO only).

Phase 2 will add:

| Dependency | Purpose |
|---|---|
| `google.golang.org/protobuf` | Protobuf runtime |
| `nhooyr.io/websocket` | WebSocket client |
| `golang.org/x/crypto` | HKDF, curve25519 (provisioning crypto) |
| `modernc.org/sqlite` | Pure-Go SQLite for persistent storage |

## Key technical challenges

### CGO store callbacks

libsignal's C FFI takes callback structs (function pointers + `void *ctx`) for store operations. Go can't pass closures as C function pointers. Solution:

1. **`pointer.go`** — a handle map that stores Go interfaces keyed by incrementing `uintptr`, passed as C `void*` (no external dependency)
2. **`callbacks.go`** — `//export` Go functions that receive raw C pointers and dispatch to the appropriate Go store interface
3. **`bridge.c`** — C bridge functions that unwrap `SignalConstPointer*` by-value wrapper structs to raw pointers before calling Go exports (required because CGO `//export` functions can't reliably receive C structs by value)

The actual store structs from the header (e.g. `SignalSessionStore`) contain a `void *ctx` plus typed function pointers like `SignalLoadSession`, `SignalStoreSession`.

### Memory management across FFI

Every C-allocated object must be explicitly freed. Each Go wrapper has a `Destroy()` method calling `signal_*_destroy()`.

The FFI uses wrapper types (`SignalMutPointer*`, `SignalConstPointer*`) around raw pointers — each is a single-field struct containing `raw`.

Borrowed C pointers in callbacks (e.g. session records, public keys passed by libsignal) are cloned via serialize/deserialize before storing in Go memory.

### Provisioning envelope crypto

Provisioning message decryption is application-level crypto, not part of libsignal FFI:
- ECDH shared secret → HKDF (info="TextSecure Provisioning Message") → 32-byte AES key + 32-byte MAC key
- Verify HMAC-SHA256, then AES-256-CBC decrypt with PKCS7 unpadding
- Pure Go: `crypto/aes`, `crypto/hmac`, `golang.org/x/crypto/hkdf`

### Message sending

Sending requires:
1. Fetch recipient's pre-key bundle from server
2. Establish session (if not exists)
3. Encrypt Content protobuf via session cipher
4. PUT encrypted envelope to `/v1/messages/{destination}`

This is covered in Signal-Android's `SignalServiceMessageSender.java`.

## Reference sources

| Source | Location | What to learn |
|---|---|---|
| Signal-Android libsignal-service | `../Signal-Android/lib/libsignal-service/` | Official service layer (canonical) |
| Signal-Android protobuf | `../Signal-Android/lib/libsignal-service/src/main/protowire/` | Message formats |
| libsignal Rust FFI | `../libsignal/rust/bridge/ffi/` | C FFI source, cbindgen config |
| Generated C header | `pkg/libsignal/libsignal-ffi.h` | Actual FFI function signatures |
| libsignalgo (archived) | `../libsignalgo/` | CGO callback patterns (reference only) |
| signalbot | `../signalbot/internal/signal/` | Current use case, target API shape |
